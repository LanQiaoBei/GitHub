1.用常数1取代运行时间中的所有加法常数。
2.在修改后的运行次数函数中，只保留最高阶项。
3.如果最高阶项存在且不是1，则去除与这个项相乘的常数。
4.得到的最后结果就是大O阶。


int i = 1, n = 100;
while( i < n )
{
i = i * 2;
}
由于每次i*2之后，就举例n更近一步，假设有x个2相乘后大于或等于n，则会退出循环。
于是由2^x = n得到x = log(2)n，所以这个循环的时间复杂度为O(logn)。

void function(int count) {
int j;
for(j=count; j < n; j++) {
    printf(“%d”, j);
}
}
function内部的循环次数随count的增加(接近n)而减少，所以根据游戏攻略算法的时间复杂度为O(n^2)。